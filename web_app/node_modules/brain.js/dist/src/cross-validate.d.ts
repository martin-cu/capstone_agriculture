import { INeuralNetworkBinaryTestResult, INeuralNetworkOptions, INeuralNetworkState, INeuralNetworkTestResult } from './neural-network-types';
export declare type ICrossValidateOptions = INeuralNetworkOptions;
export interface INetwork {
    options: any;
    trainOpts: any;
    toJSON: () => any;
    train: (data: any[], trainOpts?: any) => INeuralNetworkState;
    test: (data: any[]) => INeuralNetworkTestResult | INeuralNetworkBinaryTestResult;
}
export declare type ICrossValidateJSON<JsonType> = ICrossValidateStats<JsonType> | ICrossValidateBinaryStats<JsonType>;
export interface ICrossValidateStatsAverages {
    trainTime: number;
    testTime: number;
    iterations: number;
    error: number;
}
export interface ICrossValidateStats<JsonType> {
    avgs: ICrossValidateStatsAverages;
    stats: ICrossValidateStatsResultStats;
    sets: Array<ICrossValidationTestPartitionResults<JsonType>>;
}
export interface ICrossValidateBinaryStats<NetworkType> {
    avgs: ICrossValidateStatsAverages;
    stats: ICrossValidateStatsResultBinaryStats;
    sets: Array<ICrossValidationTestPartitionBinaryResults<NetworkType>>;
}
export interface ICrossValidateStatsResultStats {
    total: number;
    testSize: number;
    trainSize: number;
}
export interface ICrossValidateStatsResultBinaryStats extends ICrossValidateStatsResultStats {
    total: number;
    truePos: number;
    trueNeg: number;
    falsePos: number;
    falseNeg: number;
    precision: number;
    recall: number;
    accuracy: number;
}
export interface ICrossValidationTestPartitionResults<JsonType> extends INeuralNetworkTestResult {
    trainTime: number;
    testTime: number;
    iterations: number;
    network: JsonType;
    total: number;
}
export declare type ICrossValidationTestPartitionBinaryResults<JsonType> = INeuralNetworkBinaryTestResult & ICrossValidationTestPartitionResults<JsonType>;
export declare type Classifier<NetworkType extends INetwork> = new (options: NetworkType['trainOpts']) => NetworkType;
interface IStaticClassifier<NetworkType extends INetwork> extends Classifier<NetworkType> {
    fromJSON?: (json: ReturnType<NetworkType['toJSON']>) => NetworkType;
}
export default class CrossValidate<NetworkType extends INetwork> {
    Classifier: IStaticClassifier<NetworkType>;
    options: Partial<ICrossValidateOptions>;
    json: ICrossValidateJSON<ReturnType<NetworkType['toJSON']>>;
    constructor(Classifier: IStaticClassifier<NetworkType>, options?: Partial<NetworkType['options']>);
    testPartition(trainOpts: Parameters<NetworkType['train']>[1], trainSet: Parameters<NetworkType['train']>[0], testSet: Parameters<NetworkType['train']>[0]): ICrossValidationTestPartitionResults<ReturnType<NetworkType['toJSON']>> | ICrossValidationTestPartitionBinaryResults<ReturnType<NetworkType['toJSON']>>;
    /**
     * Randomize array element order in-place.
     * Using Durstenfeld shuffle algorithm.
     * source: http://stackoverflow.com/a/12646864/1324039
     */
    shuffleArray<K>(array: K[]): K[];
    static isBinaryStats: (stats: ICrossValidateStatsResultStats | ICrossValidateStatsResultBinaryStats) => stats is ICrossValidateStatsResultBinaryStats;
    static isBinaryResults: <JsonType>(stats: ICrossValidateStats<JsonType> | ICrossValidateBinaryStats<JsonType>) => stats is ICrossValidateBinaryStats<JsonType>;
    static isBinaryPartitionResults: <JsonType>(stats: ICrossValidationTestPartitionResults<JsonType> | ICrossValidationTestPartitionBinaryResults<JsonType>) => stats is ICrossValidationTestPartitionBinaryResults<JsonType>;
    train(data: Parameters<NetworkType['train']>[0], trainOpts?: Partial<Parameters<NetworkType['train']>[1]>, k?: number): ICrossValidateStats<NetworkType>;
    toNeuralNetwork(): NetworkType;
    toJSON(): ICrossValidateJSON<ReturnType<NetworkType['toJSON']>> | null;
    fromJSON(crossValidateJson: ICrossValidateJSON<ReturnType<NetworkType['toJSON']>>): NetworkType;
}
export {};
//# sourceMappingURL=cross-validate.d.ts.map